1.概念
    将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 [构建与表示分离，同构建不同表示]
    与抽象工厂的区别：在建造者模式里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。
建造模式是将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。
　　举个简单的例子，如汽车，有很多部件，车轮，方向盘，发动机还有各种小零件等等，部件很多，但远不止这些，如何将这些部件装配成一部汽车，这个装配过程也很复杂（需要很好的组装技术）， builder模式就是为了将部件和组装分开。

三、分析

通过以上建造模式的实例，我们可以总结出以下这些参与者：
Builder 一个抽象类，其中包含了对各个部件建造的抽象定义。
ConcreteBuilder 具体建造实现类，可以有一个或多个，实现创建具体部件的过程。
AbstractProduct 抽象部件类，可以有一个或多个，为一类部件对象声明一个接口。
ConcreteProduct 具体部件类，定义一个被相应的具体Builder类创建的部件对象，它继承或实现了相应的抽象部件类。
Director 指导类，实际使用Builder对象的中介类，也是使用该建造模式的一般入口。
Client 客户端，通过Director来实现建造模式。
实现一个建造模式，需要以下几个关键步骤：
1、定义一个抽象建造类，其中定义获取目标产品的建造以及出口，如buildObject和getObject。
2、定义一个或多个抽象建造类的实现类，顺带的定义了该实现类对应的实际产品种类等。
3、定义一个指导类，用抽象建造类作为参数，来实际使用已有的实际建造类。
建造模式(Builder)有着与抽象工厂模式(Abstract Factory) 一样的优缺点，它一般是用来创建一个比较复杂的大对象，里面包含了多步部件拼装的过程，而最终输出的是一个完整的大对象。
如果说和抽象工厂(Abstract Factory) 的目标是输出许多同等的产品的话，那么建造模式(Builder)应该就是输出一个完整的大对象，里面涵盖了许多个同等的子部件。

四、在什么情况下使用建造模式？
1、需要生产的产品对象有复杂的内部结构。每一个内部成分本身可以是对象，也可以仅仅是一个对象的组成部分
2、需要生产的产品对象的属性相互依赖。
3、在对象的生产过程中需要用到系统中其他的对象，这些对象在产品对象的创建过程中不宜得到。

实例：邮件